using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

using RtMidi.Core.Messages;
using RtMidi.Core.Devices.Infos;
using RtMidi.Core.Devices;

namespace AVDeviceControl
{
    public partial class ucMixer : UserControl
    {
        #region Local Variables
        MixerConfig config = new MixerConfig();
        Midi midi = null;
        Midi.MidiConnection midiConnection = null;
        List<ucVolumeSlider> sliders = new List<ucVolumeSlider>();
        Dictionary<int, ucVolumeSlider> midiChannelMap = new Dictionary<int, ucVolumeSlider>();
        Dictionary<int, ucVolumeSlider> midiCtlPointsMap = new Dictionary<int, ucVolumeSlider>();
        Dictionary<String, ucVolumeSlider> midiNamesMap = new Dictionary<String, ucVolumeSlider>();

        frmMidiTest midiTestDialog = null;

        public delegate void DeleteRequest(object sender, EventArgs e);
        public event DeleteRequest RqDelete = null;

        public event ConfigurationChanged configurationChangedEvent = null;
        public event ValueChanged valueChangedEvent = null;
        #endregion

        #region Constructors
        public ucMixer()
        {
            InitializeComponent();
            Connected = false;
        }
        public ucMixer(Midi midi, MixerConfig cfg) : this()
        {
            this.midi = midi;
            InitComboLists();

            this.config = cfg;

            mixerConfigBindingSource.DataSource = this.config;
            channelsBindingSource.DataSource = this.Config.Channels;
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// 
        /// MOVED FROM DESIGNER (where it was originally autogenerated)
        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            ExecDisconnect();

            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion

        #region Properties
        public MixerConfig Config { get { return config; } }
        public ucVolumeSlider[] Sliders { get { return sliders.ToArray(); } }
        public Midi.MidiConnection Connection { get { return midiConnection;  } }
        #endregion

        #region Initialization
        private void PositionDevices(Control panel)
        {
            int clientHeight = panel.ClientRectangle.Height - 8; // space for scrollbar
            int left = 0;
            for (int i = 0; i < sliders.Count; ++i)
            {
                ucVolumeSlider cam = sliders[i];
                //cam.Anchor = AnchorStyles.Top 
                cam.Size = new Size(cam.Width, clientHeight);
                cam.Location = new Point(left, 0);
                left += cam.Width;
            }
            this.Width = Math.Max(left + 16, 200);
        }

        private void RefreshMidis()
        {
            cmbDevices.Items.Clear();
            IMidiInputDeviceInfo[] inputs = midi.Devices;
            foreach (IMidiInputDeviceInfo item in inputs)
            {
                cmbDevices.Items.Add(item);
            }
        }
        private void InitComboLists()
        {
            RefreshMidis();
        }
        #endregion

        #region Connection
        public String Connect()
        {
            return (String)Invoke(new Action(() => { ExecConnect(); }));
        }
        public String ExecConnect()
        {
            Disconnect();
            // Connect to PtzController and camera
            if (cmbDevices.SelectedItem == null)
            {
                return "Please select a MIDI device!";
            }
            midiConnection = midi.Connect(cmbDevices.SelectedItem as IMidiInputDeviceInfo);
            if (midiConnection != null)
            {
                if (chkTest.Checked)
                {
                    midiTestDialog = new frmMidiTest(midiConnection);
                    midiTestDialog.Show();
                }
                midiConnection.inp.ControlChange += MidiRx_ControlChange;

                if (config.Y01v96)
                {
                    midiConnection.inp.SysEx += Inp_SysEx;
                }
                else
                {
                    midiConnection.inp.NoteOn += MidiRx_NoteOn;
                    midiConnection.inp.NoteOff += MidiRx_NoteOff;
                }

                tpControl.Controls.Clear();
                sliders.Clear();
                ClearMidiMap();
                foreach (MidiChannel ch in Config.Channels)
                {
                    ucVolumeSlider sld = new ucVolumeSlider(Config.Name, ch);
                    sld.MuteChangedEvent += UI_MuteChangedEvent;
                    sld.ControlValueChangedEvent += UI_ControlValueChangedEvent;
                    
                    tpControl.Controls.Add(sld);
                    sliders.Add(sld);
                    MapMidiChannel(ch, sld);
                }
                PositionDevices(tpControl);

                Connected = true;

                return null;
            }
            return "Failed MIDI Connect";
        }

        public void Disconnect()
        {
            Invoke(new Action(() => { ExecDisconnect(); }));
        }
        public void ExecDisconnect()
        {
            if (midiConnection != null)
            {
                midi.Disconnect(midiConnection);
                midiConnection = null;
            }
            Connected = false;
        }

        bool isConnected = false;
        bool Connected
        {
            get { return isConnected; }
            set
            {
                tabControl1.Visible = false;
                tabControl1.TabPages.Clear();
                if (value)
                {
                    if (!isConnected)
                    {
                        isConnected = value;
                        tabControl1.TabPages.Add(tpControl);
                        if (config.Y01v96)
                        {
                            new Thread(new ThreadStart(Poll01v96)).Start();
                        }
                        configurationChangedEvent?.Invoke(this);
                    }
                }
                else
                {
                    bool wasConnected = isConnected;
                    isConnected = value;
                    // Alway update control when not connected
                    tabControl1.TabPages.Add(tpConfigure);
                    tabControl1.SelectedTab = tpConfigure;
                    if (midiTestDialog != null) {
                        midiTestDialog.Close();
                        midiTestDialog = null;
                    }

                    if (wasConnected)
                    {
                        configurationChangedEvent?.Invoke(this);
                    }
                }
                btnDisconnect.Visible = isConnected;
                tabControl1.Visible = true;
                // pnlConnected.Visible = isConnected;
            }
        }
        #endregion

        #region Websocket to UI Support

        public void MuteButton(String channelName, bool value)
        {
            ucVolumeSlider sld;
            if (midiNamesMap.TryGetValue(channelName, out sld))
            {
                sld.MuteButton = value;
            }
        }
        public void MoveSlider(String channelName, int value)
        {
            ucVolumeSlider sld;
            if (midiNamesMap.TryGetValue(channelName, out sld))
            {
                sld.MoveSlider = value;
            }
        }

        #endregion

        #region MIDI Input to UI support
        /// <summary>
        /// Clear (reset) all of the the midi to UI element mapping
        /// </summary>
        void ClearMidiMap()
        {
            midiChannelMap.Clear();
            midiNamesMap.Clear();
        }
        /// <summary>
        /// Create mappings for channel name and for channel number / value pairs
        /// for Control (fader?) and mute
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="sld"></param>
        void MapMidiChannel(MidiChannel ch, ucVolumeSlider sld)
        {
            midiNamesMap[ch.Name] = sld;
            // Use zero based channel for map
            midiChannelMap[ch.Channel - 1] = sld;
            midiCtlPointsMap[((ch.Channel - 1) << 8) | ch.Control] = sld;
            midiCtlPointsMap[((ch.Channel - 1) << 8) | ch.Mute] = sld;
        }
        ucVolumeSlider GetByChannel(RtMidi.Core.Enums.Channel channel)
        {
            ucVolumeSlider slider;
            if (midiChannelMap.TryGetValue((int)channel, out slider))
            {
                return slider;
            }
            else
            {
                return null;
            }
        }
        ucVolumeSlider GetByCtlPoint(RtMidi.Core.Enums.Channel channel, int ctl)
        {
            ucVolumeSlider slider;
            if (midiCtlPointsMap.TryGetValue((((int)channel) <<8) | ctl, out slider))
            {
                return slider;
            }
            else
            {
                return null;
            }
        }

        private void MidiRx_NoteOff(IMidiInputDevice sender, in RtMidi.Core.Messages.NoteOffMessage msg)
        {
            ucVolumeSlider slider = GetByChannel(msg.Channel);
            if (slider != null)
            {
                slider.InputValue = 0;
                // Send event from slider, NOT midi
                valueChangedEvent?.Invoke(slider, new ValueChangedEventArgs(DeviceValueType.VolumeLevel, 0));
            }
            else
            {
                Console.WriteLine($"[{sender.Name}] NoteOff: Channel:{msg.Channel} Key:{msg.Key} Velocity:{msg.Velocity}");
            }
        }

        private void MidiRx_NoteOn(IMidiInputDevice sender, in RtMidi.Core.Messages.NoteOnMessage msg)
        {
            ucVolumeSlider slider = GetByChannel(msg.Channel);
            if (slider != null)
            {
                slider.InputValue = msg.Velocity;
                // Send event from slider, NOT midi
                valueChangedEvent?.Invoke(slider, new ValueChangedEventArgs(DeviceValueType.VolumeLevel, msg.Velocity));
            }
            else
            {
                Console.WriteLine($"[{sender.Name}] NoteOn: Channel:{msg.Channel} Key:{msg.Key} Velocity:{msg.Velocity}");
            }
        }

        private void MidiRx_ControlChange(IMidiInputDevice sender, in RtMidi.Core.Messages.ControlChangeMessage msg)
        {
            ucVolumeSlider slider = GetByCtlPoint(msg.Channel, msg.Control);
            if (slider != null)
            {
                if (msg.Control == slider.Config.Control)
                {
                    slider.ControlValue = msg.Value;
                    // Send event from slider, NOT midi
                    valueChangedEvent?.Invoke(slider, new ValueChangedEventArgs(DeviceValueType.VolumeSetting, msg.Value));
                }
                else if (msg.Control == slider.Config.Mute)
                {
                    slider.Mute = msg.Value != 127;
                    // Send event from slider, NOT midi
                    valueChangedEvent?.Invoke(slider, new ValueChangedEventArgs(DeviceValueType.Mute, msg.Value != 127));
                }
                else
                {
                    Console.WriteLine($"[{sender.Name}] Unused ControlChange: Channel:{msg.Channel} Control:{msg.Control} Value:{msg.Value}");
                }
            }
            else
            {
                Console.WriteLine($"[{sender.Name}] No control point: Channel:{msg.Channel} Control:{msg.Control} Value:{msg.Value}");
            }
        }
        #endregion

        // https://github.com/kryops/01v96-remote/blob/master/server/controllers/mixer.js
        enum sysExElements
        {
            channelFader = 28,
            sumFader = 79,
            auxSendFader = 35,
            auxFader = 57,
            busFader = 43,

            channelOn = 26,
            sumOn = 77,
            auxOn = 54,
            busOn = 41
        }

        // (0xF0) 0x43, 16, 0x3E, 0x0D, 0x21, 0, 0, 0, 8, 29, 9, 6, 2, 122, 8, 78, 4, 51, 5, 86, 2, 64, 5, 1, 4, 78, 10, 111, 2, 31, 3, 102, 4, 14, 4, 49, 2, 57, 2, 26, 1, 103, 4, 25, 6, 49, 3, 62, 7, 0, 8, 7, 4, 82, 4, 4, 3, 123, 4, 43, 2, 56, 5, 4, 4, 36, 4, 119, 9, 73, 8, 39
        //                                    H0 L0  H1 L1 ...
        private void Inp_SysEx(IMidiInputDevice sender, in SysExMessage msg)
        {
            // data starts AFTER opcode (0xF0)
            if (msg.Data[4] == 0x21)
            {
                if (msg.Data.Length > 70)
                {
                    for (int i = 0; i <= 31; i++)
                    {
                        // ASSUME ALL 01v96 (sliders and meter) are configured to Channel1 and 1 based "channel" control values
                        ucVolumeSlider slider = GetByCtlPoint(RtMidi.Core.Enums.Channel.Channel1, i + 1);
                        if (slider != null)
                        {
                            int value = msg.Data[(8 + 2 * i)] * 3;
                            // Apply to slider
                            slider.InputValue = value;
                            // Send event from slider, NOT midi
                            valueChangedEvent?.Invoke(slider,
                                new ValueChangedEventArgs(DeviceValueType.VolumeLevel, value));
                        }
                    }
                }
                else
                {
                    Console.WriteLine("SysEx (0x21) too short: " + BitConverter.ToString(msg.Data));
                }
            }
            else
            {
                ucVolumeSlider slider;
                byte element = msg.Data[5];
                byte parameter = msg.Data[6];
                byte channel = msg.Data[7];
                switch (element)
                {
                    case (byte)sysExElements.channelFader:
                        // ASSUME ALL 01v96 (sliders and meter) are configured to Channel1 and 1 based "channel" control values
                        slider = GetByCtlPoint(RtMidi.Core.Enums.Channel.Channel1, channel + 1);
                        if (slider != null)
                        {
                            int fader = (msg.Data[8] << 7) + msg.Data[9];
                            Console.WriteLine("Fader: " + fader + " on channel " + channel + " (" + msg.ToString() + ")");
                            // Apply to slider
                            slider.MoveSlider = fader;
                            // Send event from slider, NOT midi
                            valueChangedEvent?.Invoke(slider,
                                new ValueChangedEventArgs(DeviceValueType.VolumeSetting, fader));
                        }
                        break;
                    case (byte)sysExElements.channelOn:
                        // ASSUME ALL 01v96 (sliders and meter) are configured to Channel1 and 1 based "channel" control values
                        slider = GetByCtlPoint(RtMidi.Core.Enums.Channel.Channel1, channel + 1);
                        if (slider != null)
                        {
                            byte on = msg.Data[8];
                            Console.WriteLine("Channel " + channel + " on=" + on + " (" + msg.ToString() + ")");
                            slider.Mute = on != 127;
                            // Send event from slider, NOT midi
                            valueChangedEvent?.Invoke(slider,
                                new ValueChangedEventArgs(DeviceValueType.Mute, on != 127));
                        }
                        break;
                    default:
                        Console.WriteLine("Unknown SysEx" + BitConverter.ToString(msg.Data));
                        break;
                }
            }
        }

        private void Poll01v96()
        {
            
            byte element = 0;
            byte parameter = 1;

            byte[] parameterMsgStart = new byte[] { 0xF0, 0x43, 0x30, 0x3E, 0x0D, 0x01};
            for (byte channel = 0; channel < 32; ++channel)
            {
                // Parameter request (section 2.8.3.4)
                element = (byte)sysExElements.channelFader;
                byte[] msg = parameterMsgStart.Concat(new byte[] { element, parameter, channel, 0xf7 }).ToArray();
                midiConnection.outp?.Send(new SysExMessage(msg));

                element = (byte)sysExElements.channelOn;
                msg = parameterMsgStart.Concat(new byte[] { element, parameter, channel, 0xf7 }).ToArray();
                midiConnection.outp?.Send(new SysExMessage(msg));
            }
            
            while (isConnected)
            {
                //Console.WriteLine("POLL");

                // Parameter request (section 2.8.3.23) Sends every 50ms for 10 seconds
                midiConnection.outp?.Send(new SysExMessage(new byte[] {
                0xF0, 0x43, 0x30, 0x3E,    // sysEx: 0xF0, YAMAHA, 0x30+channel, Digital_mixer
                0x0D,       // 01v96
                0x21,		// Remote Meter
                0x00,		// Address UL - up to 0x22 / 34
                0x00,		// Address LU - up to 5
                0x00,		// Address LL - up to 0x27 / 39
                0,			// Count H
                32,			// Count L
                0xF7 }));

                for (int i = 0; i < 20; ++i)
                {
                    // sleep for 10 sec in 500ms chunks
                    Thread.Sleep(500);
                    if (!isConnected)
                    {
                        break;
                    }
                }
            }
        }

        #region UI to MIDI Output Support

        private void UI_ControlValueChangedEvent(object sender, int value)
        {
            MidiChannel config = (sender as ucVolumeSlider).Config;
            // Note that channel number is one based and value is zero based
            midiConnection.outp?.Send(new ControlChangeMessage((RtMidi.Core.Enums.Channel)(config.Channel - 1),
              config.Control, value));
            valueChangedEvent?.Invoke(sender, new ValueChangedEventArgs(DeviceValueType.VolumeSetting, value));
        }

        private void UI_MuteChangedEvent(object sender, bool value)
        {
            MidiChannel config = (sender as ucVolumeSlider).Config;
            // Note that channel number is one based and value is zero based
            midiConnection.outp?.Send(new ControlChangeMessage((RtMidi.Core.Enums.Channel)(config.Channel - 1),
                config.Mute, value ? 0 : 127));
            valueChangedEvent?.Invoke(sender, new ValueChangedEventArgs(DeviceValueType.Mute, value));

        }

        #endregion

        #region Datagrid Support
        private void dgChannels_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e)
        {
            e.Control.KeyPress -= new KeyPressEventHandler(Numeric_KeyPress);
            if (dgChannels.CurrentCell.OwningColumn.HeaderText != "Name") // Name is the only non-numeric column
            {
                TextBox tb = e.Control as TextBox;
                if (tb != null)
                {
                    tb.KeyPress += new KeyPressEventHandler(Numeric_KeyPress);
                }
            }
        }
        private void Numeric_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (!char.IsControl(e.KeyChar)
                && !char.IsDigit(e.KeyChar))
            {
                e.Handled = true;
            }
        }

        private void dgChannels_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
        {
            var view = (DataGridView)sender;
            view.Rows[e.RowIndex].ErrorText = "";
            if (dgChannels.CurrentCell.OwningColumn.HeaderText == "Name") // Name must be min length
            {
                if (e.FormattedValue.ToString().Length < 2)
                {
                    view.Rows[e.RowIndex].ErrorText =
                      $"'{view.CurrentCell.OwningColumn.HeaderText}' must be at least 2 characters";
                    e.Cancel = true;
                }
            }
            else
            {
                try
                {
                    int value = int.Parse(e.FormattedValue.ToString());
                    if (dgChannels.CurrentCell.OwningColumn.HeaderText == "Channel") // Name must be min length
                    {
                        if (value < 1 || value > 128)
                        {
                            view.Rows[e.RowIndex].ErrorText =
                              $"'{view.CurrentCell.OwningColumn.HeaderText}' must be in the range 1 to 128";
                            e.Cancel = true;
                        }
                    }
                    else
                    {
                        if (value < 0 || value > 127)
                        {
                            view.Rows[e.RowIndex].ErrorText =
                              $"'{view.CurrentCell.OwningColumn.HeaderText}' must be in the range 1 to 127";
                            e.Cancel = true;
                        }
                    }
                }
                catch (Exception)
                {
                    view.Rows[e.RowIndex].ErrorText =
                      $"'{view.CurrentCell.OwningColumn.HeaderText}' must be a numeric value";
                    e.Cancel = true;
                }
            }
        }
        #endregion

        #region Control Events 

        private void btnRefreshDevices_Click(object sender, EventArgs e)
        {
            RefreshMidis();
        }

        private void tpControl_Resize(object sender, EventArgs e)
        {
            PositionDevices(tpControl);
        }

        private void btnDelete_Click(object sender, EventArgs e)
        {
            if (MessageBox.Show("Are you sure you want to remove this mixer?",
                 "Deleting Mixer", MessageBoxButtons.YesNo)
                 == DialogResult.Yes)
            {
                RqDelete?.Invoke(this, new EventArgs());
            }
        }

        private void btnConnect_Click(object sender, EventArgs e)
        {
            String error = Connect();
            if (error != null)
            {
                MessageBox.Show(error, "Failed to connect MIDI");
            }
        }

        private void btnDisconnect_Click(object sender, EventArgs e)
        {
            Disconnect();
        }
        #endregion

        private void mixerConfigBindingSource_CurrentItemChanged(object sender, EventArgs e)
        {
            configurationChangedEvent?.Invoke(this);
        }
    }
}
